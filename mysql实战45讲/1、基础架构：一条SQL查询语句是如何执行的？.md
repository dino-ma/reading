# 问题
1. 一条查询语句经历了哪些过程
2. MySQL长连接长时间不释放导致的问题
3. 查询缓存为什么是个鸡肋

# 一条查询语句经历了哪些过程
```
  客户端：PHP、go、Java...
  
  连接器：管理连接、权限验证。进行连接mysql -h$ip -P$port -u$user -p,show processlist可以查看连接的情况
  查询缓存：缓存中存在的话直接返回，8.0版本后去掉了这个功能
  分析器：词法分析，语法分析
  优化器：执行explain计划生成，索引选择，字段检查
  执行器：操作引擎，返回结果

  存储引擎：存储数据，提供读写接口
```

# MySQL长连接长时间不释放导致的问题
- MySQL占用内存涨得特别快，因为长连接累积没有释放，连接断开的时候释放内存
- OOM MySQL被系统强行杀掉
  - 定期断开长连接，之后查询再重连
  - >=5.7的版本,可以在执行比较大的操作后，通过mysql_reset_connection来重新初始化连接资源

# 查询缓存为什么是个鸡肋
- 之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果
  - 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的所有查询缓存都会被清空
  - 除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存

  