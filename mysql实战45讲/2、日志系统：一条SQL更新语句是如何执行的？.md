# 问题
1. 一条更新语句经历了哪些过程
2. binlog和redo的区别
3. 为什么binlog补数据是不完整的
4. MySQL怎么恢复到半个月内任意一秒的状态
5. 为什么MySQL中的日志需要两阶段提交
6. 什么情况下一天一备或者一周一备，影响MySQL的哪些指标

# 一条更新语句经历了哪些过程
```
更新语句会走查询的全部过程，先查出来在进行更新操作
更新流程涉及2个重要的日志模块：redolog(重做日志)、binlog(归档日志)
  不是每一次的更新操作都需要立马写磁盘，整个IO成本、查询成本都很高，引入了类似酒店掌柜粉板的思路提升更新效率(WAL技术)
  Write-Ahead Logging：先写日志，等不忙或者日志满的时候在写磁盘
  2PC：更新写入redolog,处于prepare阶段->写binlog->提交事务,处于commit状态
```

# binlog和redo的区别
- binlog是归档日志，没有crash-safe的能力，binlog处于MySQL的server层，所有引擎都可以使用
- binlog有两种模式，statement格式是记sql语句，row格式会记录行的内容，记录2条，更新前和更新后的
- redolog是物理日志，有crash-safe的能力，处于innodb引擎层，记录的是某个数据页做了什么修改。binlog是记录的是语句
- redolog是循环写的，空间固定会用完；binlog是追加写的，文件写到一定大小会切换到下一个，不会覆盖以前的日志
- redolog是顺序写，并且可以组提交


# 为什么binlog补数据是不完整的
- binlog是可以关掉的，需要确保一直是打开着的
- binlog是MySQL server层的，没有crash-safe的能力，MySQL崩溃时丢的数据binlog是恢复不了的（需要借助redolog重新提交）
- 业务逻辑出现了错误的语句导致数据出错，这个从业务快速补数据，不能只靠binlog
- 应用的日志 + MySQL binlog 

# MySQL怎么恢复到半个月内任意一秒的状态
- 找到距离恢复点最近的一次备份
- 从备份的时间点开始，将备份的binlog依次取出，重放到恢复的那个时刻
- 把数据放到临时库里面，按需要恢复到线上库去

# 为什么MySQL中的日志需要两阶段提交
- redolog和binlog处于不同的层中，是两个独立的逻辑
- 两阶段提交就是让这两个状态保持逻辑上的一致(执行器把更新操作先进行redo->binlog->redo commit)

# 什么情况下一天一备或者一周一备，影响MySQL的哪些指标
- 备份就是救命药加后悔药，灾难发生的时候救命，出现错误的时候后悔
- 看业务情况和需求决定备份的频率和周期
- 一天一备份时间短binlog少，救命时更快，但后悔时间短
- 一周一备时间长binlog多，救命时慢，但后悔时间长

