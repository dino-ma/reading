# 283. 移动零
```
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
说明:
    必须在原数组上操作，不能拷贝额外的数组。
    尽量减少操作次数。
```

## 解法1
```
思路：2个循环，第一次循环把非0的提取出来，并对非0的index计数。第二次循环往数组后面追加0，直到元素个数等于数组的长度
func moveZeroes(nums []int)  {
    // 1、遍历数组，把非0的提取出来，最后补充0
    indexj := 0
    for _, num := range nums {
        if num != 0 {
            nums[indexj] = num
            indexj++
        }
    }

    // 补充0
    total := len(nums)
    for indexj < total {
        nums[indexj] = 0
        indexj++
    }
}
```

## 解法2
```
思路：1个循环，把非0和0的位置进行交换，滚雪球方式(交换0和非0的元素的位置)，对0的个数计数，把非0的和最左边的0交换位置(跳到长度的最左边即可)
func moveZeroes(nums []int)  {
    zeroTotal := 0
    count := len(nums)
    for i := 0;i < count; i++ {
        if nums[i] == 0 {
            zeroTotal++
        } else if (zeroTotal > 0) { // 当前元素不为0,才走到else
            // 交换到zeroTotal长度的最左边
            nums[i - zeroTotal] = nums[i]
            nums[i] = 0
        }
    }
}
```


# 11.盛最多水的容器
```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。
```

## 解法1
```
思路：暴露破解，2层循环找出最大值
func maxArea(height []int) int {
    total,maxArea := len(height),0
    for i := 0; i < total; i++ {
        for j := i + 1; j < total; j++ {
            minHeight := height[i]
            if minHeight > height[j] {
                minHeight = height[j]
            }

            tempArea := (j-i) * minHeight
            if maxArea < tempArea {
                maxArea = tempArea
            }
        }
    }
    return maxArea
}
```

## 解法2
```
思路：一层循环,使用2个指针往两头开始夹逼,不断的找最高的height
func maxArea(height []int) int {
    // i表示左,j表示右
    i,j,maxArea := 0,len(height) - 1,0
    for i < j {
        minHeight := height[i]
        if minHeight > height[j] {
            minHeight = height[j]
        }

        tempArea := minHeight * (j - i)
        if maxArea < tempArea {
            maxArea = tempArea
        }

        if height[i] > height[j] {
            j--
        } else {
            i++
        }
    }
    return maxArea
}
```

# 70.爬楼梯
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
```

## 解法1
```
思路：归纳法得出递归公式，使用map把每个台阶的走法数都存储起来
func climbStairs(n int) int {
    pb := make(map[int]int, 0)
    pb[0] ,pb[1], pb[2] = 0, 1, 2
    for i := 3; i <= n; i++ {
        pb[i] = pb[i-1] + pb[i-2]
    }
    return pb[n]
}
```

## 解法2
```
思路：使用map会消耗较多的空间，能否改为只使用变量去存储结果
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    rtn,stepOne,stepTwo := 0,1,2
    for i := 3; i <= n; i++ {
        rtn = stepOne + stepTwo
        stepOne = stepTwo
        stepTwo = rtn
    }
    return rtn
}
```

# 1.两数之和
```
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
```

## 解法1
```
思路：暴力求解，两重循环去找到那2个数
func twoSum(nums []int, target int) []int {
    // 暴力求解,两重循环
    total,rtn := len(nums), make([]int, 0)
    for i := 0; i < total; i++ {
        for j := i+1; j < total; j++ {
            if nums[i] + nums[j] == target {
                rtn = append(rtn, i)
                rtn = append(rtn, j)
            }
        }
    }
    return rtn
}
```

## 解法2
```
思路：使用一个hashmap，用空间换时间的方式
func twoSum(nums []int, target int) []int {
    // 1、第一次遍历使用hashmap把数据进行存储，把值作为key，需要查找的下标做为val
    // 2、第二次遍历查找hashmap即可
    total := len(nums)
    hashMap := make(map[int]int, 0)
    for i := 0; i < total; i++ {
        key := nums[i]
        hashMap[key] = i
    }

    rtn := make([]int, 0) 
    for i := 0; i < total; i++ { 
        findNum := target - nums[i]
        // 同一个元素不能使用2遍
        index, find := hashMap[findNum]
        if find && index != i {
            rtn = append(rtn, i)
            rtn = append(rtn, index)
            return rtn
        }
    }
    return rtn
}
```

## 解法3
```
思路：使用hashmap，遍历一遍即可
func twoSum(nums []int, target int) []int {
    // 使用hashmap把数据进行存储，把值作为key，需要查找的下标做为val
    // 一次遍历查找hashmap即可
    total, rtn := len(nums), make([]int, 0)
    hashMap := make(map[int]int, 0)
    for i := 0; i < total; i++ {
        findNum := target - nums[i]
        // 每次都是找除了自身以外之前写入的（这样同一个元素就不会使用两遍）
        if index, find := hashMap[findNum]; find {
            rtn = append(rtn, i)
            rtn = append(rtn, index)
            return rtn
        }
        key := nums[i]
        hashMap[key] = i
    }
    return rtn
}
```

## 解法4
```
把数组排序好,可以使用双指针找到那2个数即可
```

# 15.三数之和
```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
```

