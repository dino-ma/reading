# 283. 移动零
```
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
说明:
    必须在原数组上操作，不能拷贝额外的数组。
    尽量减少操作次数。
```

## 解法1
```
思路：
    2个循环，第一次循环把非0的提取出来，并对非0的index计数
    第二次循环往数组后面追加0，直到元素个数等于数组的长度

    func moveZeroes(nums []int)  {
        // 1、遍历数组，把非0的提取出来，最后补充0
        indexj := 0
        for _, num := range nums {
            if num != 0 {
                nums[indexj] = num
                indexj++
            }
        }

        // 补充0
        total := len(nums)
        for ; indexj<total; indexj++ {
            nums[indexj] = 0
        }
    }
```

## 解法2
```
思路：
    1个循环，把非0和0的位置进行交换
    滚雪球方式(交换0和非0的元素的位置)，对0的个数计数，把非0的和最左边的0交换位置(跳到长度的最左边即可)

    func moveZeroes(nums []int)  {
        zeroTotal := 0
        count := len(nums)
        for i := 0;i < count; i++ {
            if nums[i] == 0 {
                zeroTotal++
            } else if (zeroTotal > 0) { // 当前元素不为0,才走到else
                // 交换到zeroTotal长度的最左边
                nums[i - zeroTotal] = nums[i]
                nums[i] = 0
            }
        }
    }
```
