# 可靠性
```
消息的可靠性投递主要指：在发送和接收过程中，能够做到不丢消息、消息不重复两点
```

## 消息丢失的情况
![markdown](https://github.com/youngperson/reading/blob/master/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/images/msgLost.png)
```
1.把消息发送到IM服务器的过程，由于网络等问题失败了
2.IM服务器收到消息进行存储时失败了
3.消息发送方等待IM服务器一定的超时时间,但IM服务器一直没有返回结果,发送方会认为发送失败
4.IM服务器存储完后,响应发送方消息发送成功,然后IM服务器把消息推给接收方,这个过程可能会失败
5.接收方收到了消息,在处理过程中出现问题,也可能导致消息丢失
```

### 解决丢失的方案
![markdown](https://github.com/youngperson/reading/blob/master/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/images/msgAck.png)
```
1.针对发送方到IM服务器这部分,发送方失败/超时重发 + IM服务器去重
2.针对IM服务器到接收方这部分,需要实现业务层的ACK(确认Acknowledge)协议
业务层ACK参考了 TCP 协议的重传机制。类似的，IM 服务器的“等待 ACK 队列”一般都会维护一个超时计时器，一定时间内如果没有收到用户 B 回的 ACK 包，会从“等待 ACK 队列”中重新取出那条消息进行重推。
```

## 消息重复推的情况
```
对于推送的消息，在一定时间内没有收到ACK包，会触发服务端的重传。
收不到ACK的情况有两种(有几个环节就有几种可能)，推送失败、推过去了但是接收方回的ACK包丢了
对于第二种情况，ACK 包丢失导致的服务端重传，可能会让接收方收到重复推送的消息
```

### 解决重复推的方案
```
服务端推送消息时携带一个 Sequence ID，Sequence ID 在本次连接会话中需要唯一，针对同一条重推的消息 Sequence ID 不变，接收方根据这个唯一的 Sequence ID 来进行业务层的去重，这样经过去重后，对于用户 B 来说，看到的还是接收到一条消息，不影响使用体验。
```

# 可靠性的方案
![markdown](https://github.com/youngperson/reading/blob/master/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/images/msgVersion.png)
```
ACK+超时重传+去重，能够解决大部分用户在线时消息推送丢失和重复的问题，但是不能解决因IM服务器宕机导致的重传失效的情况(消息丢失了)
服务器机器宕机，重传这条路走不通了。让服务端有能力进行完整性检查，发现用户 B“有消息丢失”的情况，就可以重新同步或者修复丢失的数据。
消息完整性检查的实现机制有“时间戳比对”，由于时间戳可能存在多机器时钟不同步的问题，所以可能存在一定的偏差，导致数据获取上不够精确。所以在实际的实现上，也可以使用“全局的自增序列作为版本号”来代替。
总结：ACK(解决丢失)+超时重传(解决丢失)+去重(解决重复)+消息完整性检查(解决重传不可达的情况)
```
<table>
    <tr>
        <td>方案</td>
        <td>使用场景</td>
        <td>解决的问题</td>
        <td>引入的问题</td>
    </tr>
    <tr>
        <td>发送方重传</td>
        <td>发送方->服务器</td>
        <td>确保发送方到服务器的环节是成功的,不丢失</td>
        <td>引入重复的问题,服务器端需要根据唯一标识进行去重</td>
    </tr>
    <tr>
        <td>业务层ACK</td>
        <td>服务器->接收方</td>
        <td>确保服务器到接收方的环节是成功的,不丢失</td>
        <td>引入重复的问题,接收方需要根据唯一标识进行去重</td>
    </tr>
    <tr>
        <td>消息完整性检测</td>
        <td>接收方记录上次成功的消息版本号</td>
        <td>解决重传消息不可达的特殊场景</td>
        <td>引入全局的自增序列作为消息版本号</td>
    </tr>    
</table>

# 问题和解决方案
```
1、有了 TCP 协议本身的 ACK 机制为什么还需要业务层的 ACK 机制？
通过业务层的ack来提供保障，客户端只有都执行成功才会回ack给服务端
两个ack的作用不同，tcp的ack表征网络层消息是否送达；业务层ack是真正的业务消息是否送达和是否正确处理
即使数据成功发送到接收方设备了，tcp层再把数据交给应用层时也可能出现异常情况，比如存储客户端的本地db失败，导致消息在业务层实际是没成功收到的。
```