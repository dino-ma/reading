# 未读消息
```
消息未读数如果出现问题会影响用户的体验性，”未读数“是一种强提醒方式(APP角标、APP内部的Tab数字标签)
实时性、可靠性、一致性、安全性这些是IM的刚需，另外一个需要考虑的就是用户的体验性
这里的未读数有两个：”总未读“、”会话未读“
会话未读：当前用户和某一个人/一个群聊/一个房间的未读消息数
总未读：所有会话未读的总和
```

# 会话未读和总未读单独维护
```
理论上是可以维护未读数就可以，然后算出总未读数。
总未读经常会在消息推送的时候把总未读带上用于角标未读展示
对于高频使用到的总未读，如果每次都通过聚和所有会话来获取，容易出现某些会话未读由于超时等原因没取到
```

## 未读数的一致性问题
```
消息未读数中的总未读和会话未读单独维护能解决总未读被”高频“访问性能的问题(聚和查询会话未读)，但是单独维护带来的问题：未读数的一致性
维护的总未读数!=会话未读的总和，就会出现有消息但没未读提示、没消息但是是有未读提示
本质：并发更新问题，两个未读的变更不是原子性的
```

# 保证未读更新的原子性
<table>
    <tr>
        <td>方案</td>
        <td>实现</td>
        <td>优点</td>
        <td>缺点</td>
    </tr>
    <tr>
        <td>分布式锁</td>
        <td>依赖DB的唯一性、memcache的add、Redis的setNx</td>
        <td>普适性</td>
        <td>执行效率差、锁的管理复杂、适用于小规模的IM</td>
    </tr>
    <tr>
        <td>支持事务</td>
        <td>Redis watch</td>
        <td>不需要额外维护锁的资源、实现简单</td>
        <td>基于乐观锁的watch机制在高并发场景失败率高、执行效率容易出现瓶颈</td>
    </tr>
    <tr>
        <td>原子化嵌入脚本</td>
        <td>Redis嵌入Lua脚本</td>
        <td>不需要额外维护锁的资源、实现简单、高并发下性能也较好</td>
        <td>嵌入脚本开发需要学习成本、Lua脚本中不要有远程访问和耗时操作(避免hang住导致资源不可用)</td>
    </tr>        
</table>

# 问题和解决方案
```
1、类似 Redis+Lua 的原子化嵌入脚本的方式，是否真的能够做到“万无一失”的变更一致性？比如，执行过程中机器掉电会出现问题吗？
执行过程机器掉电的概率很小，如果出现那数据还是会出现不一致的。有可能执行到了会话未读的变更总未读还未变更机器断电了。
做不到万无一失，可以在会话数比较少的情况下聚和一次去覆盖总未读数，达到最终未读数是一致性的
```